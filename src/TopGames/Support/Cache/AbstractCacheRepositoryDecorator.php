<?php

namespace TopGames\Support\Cache;

use TopGames\Libraries\Tough\Repos\RepositoryCacheableQueriesInterface;

use BadMethodCallException;

abstract class AbstractCacheRepositoryDecorator implements RepositoryCacheableQueriesInterface {

    /**
     * @var CacheInterface
     */
    protected $cache;

    /**
     * Name of current active class
     *
     * @var string
     */
    protected $modelClass;

    /**
     * @var RepositoryCacheableQueriesInterface
     */
    protected $repo;

    /**
     * Section of the Cache the repo belongs to
     *
     * @var string
     */
    protected $section;

    /**
     * Construct
     *
     * @param RepositoryCacheableQueriesInterface $repo
     * @param CacheInterface $cache
     */
    public function __construct(RepositoryCacheableQueriesInterface $repo, CacheInterface $cache)
    {
        $this->repo = $repo;
        $this->cache = $cache;

        // Old code, before using ReflectionClass
        // $this->modelClass = $repo->getModelClass();

        $reflection = new \ReflectionClass($repo);
        $constructor = $reflection->getConstructor();
        $this->modelClass =$constructor->getParameters()[0]->getClass()->name;
    }


    public function __call($method, $parameters)
    {
        if(method_exists($this, $method))
        {
            return call_user_func_array(array($this, $method), $parameters);
        }

        if(method_exists($this->repo, $method))
        {
            return call_user_func_array(array($this->repo, $method), $parameters);
        }

        throw new BadMethodCallException('RuntimeException in '.__METHOD__.' at line '.__LINE__.": Called not existent method $method by class ".get_class($this));
    }


    /**
     * All
     *
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function all()
    {
        $key = $this->getKey();

        $tags = $this->getTags();

        if($this->cache->has($key, $tags))
        {
            return $this->cache->get($key, $tags);
        }

        $collection = $this->repo->all();

        $this->cache->put($key, $collection, $tags);

        return $collection;
    }


    /**
     * Find
     *
     * @param int $id
     * @param array $with
     * @return \Illuminate\Database\Eloquent\Model
     */
    public function find($id, array $with = array())
    {
        $key = $this->getKey($id, $with);

        $tags = $this->getTags($id, $with);

        if($this->cache->has($key, $tags))
        {
            return $this->cache->get($key, $tags);
        }

        $model = $this->repo->find($id, $with);

        $this->cache->put($key, $model, $tags);

        return $model;
    }




    /**
     * Find or throws exception
     *
     * @param int $id
     * @param array $with
     * @return \Illuminate\Database\Eloquent\Model
     */
    public function findOrFail($id, array $with = array())
    {
        $key = $this->getKey($id, $with);

        $tags = $this->getTags($id, $with);

        if($this->cache->has($key, $tags))
        {
            return $this->cache->get($key, $tags);
        }

        $model = $this->repo->findOrFail($id, $with);

        $this->cache->put($key, $model, $tags);

        return $model;
    }




    /**
     * Return Cache key generated by using the current active class, id and $with array
     *
     * @param bool $id
     * @param array $array
     *
     * @return string
     */
    protected function getKey($id = FALSE, array $array = array())
    {
        $string = $this->getString($id, $array);

        return md5($string);
    }



    /**
     * Return the ready-to-be-encrypted-string key generated by using the current active class, id and $with array
     *
     * @param bool $id
     * @param array $array
     *
     * @return string
     */
    protected function getString($id = FALSE, array $array = array())
    {
        $string = $this->section.$this->modelClass;

        if($id) {
            $string = $string.'id'.$id;
        }

        if($array) {
            foreach($array as $key => $value) {
                $string = $string.$key;
            }
        }

        return $string;
    }




    /**
     * Return Cache tags generated by using the current active class, id and with array
     *
     * @param bool $id
     * @param array $array
     *
     * @return array
     */
    protected function getTags($id = FALSE, array $array = array())
    {
        $tags = [$this->section, $this->modelClass];

        if( $id ) {
            $tags[] = $this->modelClass.'id'.$id;
        }

        if( $array ) {
            foreach( $array as $relation ) {
                $tags[] = $relation;
            }
        }

        return $tags;
    }








    /**
     * Return a method-customized Cache key generated by using the current active class, id and $with array
     * If not customName is provided, the name of the calling method will be used.
     *
     * @param bool|string $customName
     * @param bool $id
     * @param array $array
     *
     * @return string
     */
    public function getCustomMethodKey($customName = FALSE, $id = FALSE, array $array = array())
    {
        if( !$customName ) {
            $customName=debug_backtrace()[1]['function'];
        }

        $string = $this->getString($id, $array).$this->modelClass.$customName;

        return md5($string);
    }




    /**
     * Return Cache tags generated by using the current active class, id and with array.
     * It has an additional method-customized tag.
     * If not customName is provided, the name of the calling method will be used.
     *
     * @param bool|string $customName
     * @param bool $id
     * @param array $array
     *
     * @return array
     */
    public function getCustomMethodTags($customName = FALSE, $id = FALSE, array $array = array())
    {
        if( !$customName ) {
            $customName=debug_backtrace()[1]['function'];
        }

        $tags = $this->getTags($id, $array);
        $tags[] = $this->modelClass.$customName;

        return $tags;
    }


}